* The Authoring Shell and Modal Systems
**  A useful set of pieces to model a complex system:
   That uses:
   1) Static data nodes
   2) Scoped and Global Rules
      collections of rules that apply to categories of relations.
      [X,i] rules get applied to instantiations, 
      [Y,S] rules apply to defined scopes. Global, local, descendents, ancestors..., things with a tag T
   3) Instantiation rules
      1 and 2 get towards describing a platonic item. IRs allow 'there are
      25 apples, with the instId of 0-25, in play in the world'.
      String instantiation and modification would fit here to.
   4) FSMs
      Enabling transition systems between states of the local world's instantiations
   5) Parameterised freedom

   6) Layers, Gradient Descent, Evolution,  
      By Specifying layers and groups with parameterised freedom,  be able to
      treat them as nodes in a network, and have them learn, die, mate...


   If you represent all of these with a level of abstraction to get them
   all similar, authoring could become alot easier.
** A Modal editor, where a node can have the forms:

   1) A Raw Node, with variables
   2) A Node where Children are alternatives. Array/Set/Queue/Stack behaviour
   3) A Node where variables are instantiations. 
      Ie: parent's are prototypes or components, and children are existing instantiations.
      Instantiations can be existentially exclusive of a set of options,
      mututally exclusive, complementary, inclusive, indexed.
   4) A Node as a rule, where parents are conditions, children are actions, and the node body holds transforms of bound variables
      Where nodes are the the fluents being tested and manipulated in conditions, and actions.
      Rules would be instantiable themselves, able to act in particular scopes, 
      applicable only when attached to an instance
      able to test for instances, and select them by index
   5) A Node as a FSM, where the fsm has states, and conditions as modal children. (An FSM would also be instantiable)
      Instiantiable, and then testable.`
   6) A Node that collects a group of rules into a category, a variation on (2)
   7) A Node that has a defined substructure 
      So a prototypical copy of another segment of the shell?
   8) A Node where nodes have modification controlled
      Either permanently, modifiably, depthly or shallowly. Down to specified options, or freely.
   9) A Node where change can view positively or negatively, and action taken accordingly?
      Where there is a defined error assessment?


   What does this result in as a semantics and structures for node, that will cover everything else?
*** Structure:
    The node would need a unique id, and a dictionary of modes that it fulfills.
    Categories being:
    Variable-value edges
    Value-node edges
    Parent-Child Edges
    Condition-Rule-Action Edges
    Instantiation-Exclusion-Alternative edges
    FSM-Event-State edges
    Local-Rule edges
    Instantiation-Rule edges
  
  

** On Learning Haskell, Monads and Parsers in the right way
   While haskell is great, it is the wrong language to use to learn how to write haskell.
   Javascript is the *right* way to learn haskell, then you add types.

   Although Monads are a type theory concept, they are a *functional* construct. By which I mean that although type theory
   describes and enables monads, they only *require* the ability to do first class functional programming. They are used as 
   a means to solve a problem, namely, *code repetition*.

   Parsers are the prime area to learn and use monads, and not in haskell. In Haskell you get bogged down in the type system. 
   In javascript, you have to track it in your head, but also learn the underlying patterns.

   Namely, the ability to pass a function in, and possibly use it, possibly do something else, but still returning a result
   that can be used in a similarly chained function.
   Text -> (Maybe Parse).
   
   ... Here, follow the example out. expanding out what monads save in terms of if tests and hard coding
   Show why 'return' is better seen as 'lift', to take a value, and return the value the input wrapping function can use. 
   
   Parsing shows how to chain functions together.
   Also, Parsec shouldn't be imported unqualified when learning. Everything should . Parsec.<|> etc

** Red-black heuristic ranking
   Apply a Beachline style red-black tree to ranking/weighting.
   leaves will form a (possibly bin'd) ordering of weights.
   Don't bother giving the value itself, just its relation to neighbours.
   Red-black keeps it balanced so you don't need too many pairings to determine a rank
   


* An authoring methodology
  BOD would have primitives described, then repeatedly refine each level.
  Instead, have questions, work out from the middle to define inputs and outputs.
  
  Have a hypergraph of institutions of the form:
  inputs -> Institutional Spec -> outputs

  Described by repeatedly asking questions to refine the specification:

  What is the name of the Institutions?
  What are the core values of {name}?
  What are some Categories / Roles in {name} ?
  What is the role structure for {name} ?
  What are the performable actions ?
  What are the goals?
  What are the jobs / permissions ?
  What can be delegated?
  What can be parallelised?
  What can be split across sessions?
  What are the habits?
  What are the sanctions?
  What is the weighting of values / roles/ categories / goals / jobs /sanctions ? ( use heuristic weighting )
  What are the physical laws? (unmodifiable rules of physicality)
  What are the communicative acts?
  What are the regulative laws? 
  What are the normative expectations? 
  What are the monitoring / sanctioning / disrupting activities?
  What are the artifacts?
  What are the artifact specification rules?
  What are the object standards?
  What are the symbolic variations of artifacts?
  What are the artifacts functional uses?
  What is the IGU in {name}? Person / Role / Group / Institution  -> specify
  Who are the incumbents of the institution?
  Who are the challengers of the institution?
  For each activity, what is its object, what are the tools usable in the activity?
  What community of individuals are involved with the task, what is the division of labour?
  And What are the additional rules beyond that?
  What is the time/space specification of the activities / jobs/ roles ...?
  

  Carriers: Symbolic Systems, relational systems, activities, artifacts (for scott)
  Pillars: Regulative, Normative, Cultural Cognitive
  With Institutional Entrepreneurs

  
